---  
layout: post  
title: 정보처리기사 8장 서버프로그램 구현
subtitle : 정보처리기사 
tags: [자격증]  
author: Kwon 
comments : True  
---  
# 8장 서버 프로그램 구현

## 1. 개발환경 구축

개발환경 구성 시 구현될 시스템 요구사항의 명확한 이해 필요  
개발 도구, 서버 선정/ 개발 도구 사용 편의성, 성능, 라이선스 확인

#### 개발 도구 분류

- 빌드 도구  
  작성한 코드의 빌드 및 배포를 수행  
  e.g Maven, Gradle
- 구현 도구  
  개발자의 코드 작성과 디버깅, 수정 등과 같은 작업을 지원  
  e.g eclipse, intelliJ, STS, vscode
- 테스트 도구  
  코드의 기능 검증과 전체의 품질을 높이기 위해 사용  
  e.g xUnit, PMD, Cppcheck
- 형상 관리 도구  
  개발자들이 작성한 코드와 리소스 등 산출물에 대한 버전 관리를 위한 도구  
  e.g Git, CVS

### 개발환경 구성요소

#### 서버 하드웨어 개발환경

1. 웹 서버  
   클라이언트에게 정적 파일(HTML, CSS, JS)을 제공하는 웹서버 어플리케이션이 설치된 하드웨어  
   HTTP를 이용한 요청/응답을 처리  
   e.g Apache Web Server, IIS, nginx

2. 웹 애플리케이션 서버(WAS)  
   동적인 웹 서비스를 제공하기 위한 미들웨어가 설치된 하드웨어  
   클라이언트 요청에 맞는 동적인 컨텐츠(Servlet, JSP) 생성  
   e.g Tomcat, Jeus

3. 데이터베이스 서버  
   데이터의 저장과 관리를 위한 데이터베이스 소프트웨어가 설치된 하드웨어  
   e.g Oracle, MySQL, MSSQL

4. 파일 서버  
   사용자의 파일을 저장하고, 공유할 목적으로 구성된 하드웨어

#### 형상관리

소프트웨어 개발을 위한 전체 과정에서 발생하는 모든 항목의 변경 사항을 관리하기 위한 활동  
소프트웨어 생명주기 동안 발생하는 변경사항을 통제하기 위한 관리 방법

**도구 유형**

- 공유 폴더 방식(RCS, SCSS)  
  약속된 위치의 공유 폴더에 복사
- 클라이언트/서버 방식(CVS, SVN)
  중앙에 버전 관리 시스템을 항시 동작
- 분산 저장소 방식(Git)  
  로컬 저장소와 원격 저장소로 분리되어 분산 저장

```
버전 관리 도구별 특징
CVS
  다수의 인원이 동시에 범용적인 운영체제로 접근 가능
SVN
  하나의 서버에서 소스를 쉽고 유용하게 관리 가능
RCS
  소스 파일의 수정을 한 사람만으로 제한
Bitkeeper
  대규모 프로젝트에서 빠른 속도를 내도록
Git
  리누스 토발즈 개발
Clear Case
  IBM에서 개발
```

> **형상관리의 절차**
>
> - 형상 식별  
>   형상 관리의 시작  
>   시스템을 구성하는 요소들 중 형상 관리의 대상들을 구분하고 관리 목록의 번호를 정의하여 부여
> - 형상 통제  
>   소프트웨어 형상 변경 요청을 검토하고 승인하여 현재의 베이스라인에 반영될 수 있도록 통제  
>   형상통제위원회의 승인을 통한 변경 통제가 이루어진다(형상 항목의 버전 관리를 위함)
> - 형상 감사  
>   형상 항목의 변경이 계획에 따라 제대로 이뤄졌는지를 검토하고 승인
> - 형상 기록  
>   소프트웨어 형상 및 변경관리에 대한 각종 수행결과를 기록, 보고서 작성

> **관리 도구 사용 유의점**
>
> 1. 버전에 대한 쉬운 정보 접근성
> 2. 불필요한 사용자에 대한 접근 제어
> 3. 동일 프로젝트에 대한 동시 사용성
> 4. 빠른 오류 복구

## 2. 공통 모듈 구현

#### 모듈

그 자체로 하나의 완전한 기능을 수행할 수 있는 독립된 실체  
모듈화를 통해 분리된 시스템의 각 기능들

#### 모듈화

소프트웨어의 성능을 향상시키거나 복잡한 시스템의 수정, 재사용, 유지 관리 등이 용이하도록 기능 단위의 모듈로 분해하는 설계 및 구현 기법

#### 공통 모듈 구현

소프트웨어 개발에 있어 기능을 분할하고 추상화하여 성능을 향상시키고 유지보수를 효과적으로 하기위한 공통 컴포넌트 구현 기법  
모듈 간의 결합도는 줄이고 응집도는 높인 공통 모듈 구현 권장

### 소프트웨어 모듈 응집도

#### 응집도

모듈의 독립성을 나타내는 정도(모듈 내부 구성요소 간 연관 정도)  
하나의 모듈은 하나의 기능을 수행할수록 응집도가 높다

> **응집도 유형**
>
> 1. 우연적 응집도 `Coincidental`  
>    모듈 내부의 각 구성요소가 연관 없음
> 2. 논리적 응집도 `Logical`  
>    유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리
> 3. 시간적 응집도 `Temporal`  
>    특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리
> 4. 절차적 응집도 `Procedual`  
>    모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행
> 5. 통신적 응집도 `Communication`  
>    동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여 있음
> 6. 순차적 응집도 `Sequencial`  
>    모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동이 사용
> 7. 기능적 응집도 `Functional`  
>    모듈 내부의 모든 기능이 단일한 목적을 위해 수행됨

-> 응집도가 높아질수록 품질이 좋아진다(우연 < 기능)

#### 결합도

모듈 내부가 아닌 외부의 모듈과의 연관도 또는 모듈 간의 상호의존성  
소프트웨어 구조에서 모듈 간의 관련성을 측정하는 척도

> **결합도 유형**
>
> 1. 내용 결합도 `Content`  
>    다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우
> 2. 공통 결합도 `Common`
>    파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호 작용
> 3. 외부 결합도 `External`  
>    어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조
> 4. 제어 결합도 `Control`  
>    단순 처리할 대상인 값만 전달되는 게 아니라 어떻게 처리를 해야 한다는 제어 요소가 전달되는 경우
> 5. 스탬프 결합도 `Stamp`  
>    모듈 간의 인터페이스로 배열이나 오브젝트, 스트럭처 등이 전달되는 경우
> 6. 자료 결합도 `Data`  
>    모듈 간의 인터페이스로 값이 전달되는 경우

-> 결합도가 낮을수록 품질이 좋아진다(자료 < 내용)

#### 공통 모듈 구현 절차

`DTO/VO -> SQL -> DAO -> Service -> Controller -> 화면 구현`  
![Untitled](https://velog.velcdn.com/images/ocy7111/post/3fe56bde-49f2-43a3-89df-90cb22ea75e8/image.png)

- DTO : 데이터 전송 객체, getter/setter만 포함
- VO : 도메인에서 속성들을 묶어 특정 값을 나타내는 객체, readonly
- DAO : 실질적으로 DB에 접근
- Service : DAO 클래스를 호출
- Controlloer : 비즈니스 로직 수행

#### 팬인/팬아웃

소프트웨어의 구성요소인 모듈을 계층적으로 분석하기 위해 활용  
팬인/팬아웃 분석을 통해 시스템의 복잡도 추정 가능

- 팬인  
  얼마나 많은 모듈들이 현재 모듈을 호출하는지  
  해당 모듈로 들어오는 상위 모듈 수
- 팬아웃  
  해당 모듈에서 호출하는 하위 모듈 수

![Untitled](https://mblogthumb-phinf.pstatic.net/20150310_68/xpiart_14259329871534lWzT_PNG/%C1%A6%B8%F1_%BE%F8%C0%BD.png2.png?type=w2)

### 공통 모듈 테스트 종류

- 화이트박스 테스트  
  소스코드를 보면서 테스트 케이스를 다양하게 만들어 테스트 수행
- 메서드 기반 테스트  
  메서드에 서로 다른 파라미터 값을 호출하면서 테스트 수행
- 화면 기반 테스트  
  화면에 직접 데이터를 입력하여 테스트 수행
- 테스트 드라이버/테스트 스텁 활용 테스트
  - 테스트 드라이버 : 하위 모듈은 있지만 상위 모듈은 없는 경우 사용
  - 테스트 스텁 : 상위 모듈은 있지만 하위 모듈은 없는 경우 사용

## 3. 서버 프로그램 구현

업무 프로세스를 기반으로 개발언어와 도구를 이용해 서버에서 서비스 제공에 필요한 기능을 구현  
백엔드와 프론트엔드를 구분하여 구현한다

> 공통모듈 구현 절차와 동일

## 4. 배치 프로그램 구현

사용자와의 상호 작용 없이 일련의 작업들을 작업 단위로 묶어 정기적으로 반복 수행하거나 정해진 규칙에 따라 일괄 처리하는 방법

**배치 프로그램 유형**

- 이벤트 배치 : 사전에 정의해둔 조건 충족시 자동으로 실행
- 온디멘드 배치 : 사용자의 명시적 요구가 있을 때마다 실행
- 정기 배치 : 정해진 시점에 정기적으로 실행

> **배치 스케줄러 종류**
>
> 1. 스프링 배치  
>    스프링 프레임워크의 3대 요소를 모두 사용할 수 있는 대용량 처리를 제공
> 2. 쿼츠 스케줄러  
>    오픈 소스 기반 스케줄러

#### Cron 표현식

스케줄러를 실행시키기 위해 작업이 실행되는 시간 및 주기 등을 설정할 때 사용하는 표현식  
![Untitled](https://madplay.github.io/img/post/2018-08-26-a-guide-to-cron-expression-1.jpg)
쿼츠 크론 : `초 분 시 일 월 요일 (연도) 명령어`  
리눅스/유닉스 : `분 시 일 월 요일 (연도) 명령어`

- \* 모든 수
- ? 해당 항목을 미사용
- \- 기간 설정
- , 특정 기간 설정
- / 시작시간과 반복 간격 설정
- L 마지막 기간에 동작
- W 가장 가까운 평일에 동작
- \# 몇 번째 주, 요일 설정
