---
layout: post
title: 정보처리기사 6장 프로그래밍 언어 활용
subtitle: 정보처리기사
tags: [자격증]
author: Im
comments: True
---

# 6. 프로그래밍 언어 활용

## 01. 기본 문법 활용하기

### 1. 프로그래밍을 위한 기본 사항

a. 진수  
\- 특정 개수의 숫자만을 이용하여 수를 나타내는 수 체계
\- 10진수 이하일 때는 0~9를 사용하지만, 10진수 초과할 경우는 영어 알파벳을 이용함  
b. 아스키 코드(American Standard Code for Information Interchange)
\- 미국 ANSI에서 표준화한 정보교환용 부호체계
\- 영문 키보드로 입력할 수 있는 모든 기호가 할당된 기본적인 부호체계  
\* 65 => A, 97 => a

### 2. 변수 활용

a. 데이터 타입

-   개념  
    \- 프로그래밍 언어에서 실수치, 정수 자료형과 같은 여러 종류의 데이터를 식별하는 형태  
    \- 메모리 공간을 효율적으로 사용하고 2진수 데이터를 다양한 형태로 사용하기 위해 존재  
    \* 파이썬은 데이터 타입이 존재 하지만, 명시하지 않아도 값에 맞춰서 선언됨

-   데이터 타입 유형
    -   불린(Boolean): 참/거짓, C언어 미지원 (자바-true/false, 파이썬-True/False)
    -   문자(Character): 문자 하나, 메모리에 저장은 숫자로 저장됨(char)
    -   문자열(String): (C언어-char[], 자바-String)
    -   정수 타입(Integer): (int)
    -   부동 소수점(Floating Point): 소수점을 포함하는 실숫값을 저장할 때(float, double)  
        \* float-4byte, 소수점6자리 / double-8byte, 소수점15자리

b. 기본 저장 공간

-   변수  
     - 일반 변수  
    \- 저장하고자 하는 어떤 값이 있을 때, 주기억장치에 기억하기 위한 공간(C언어는 변수 선언 O, 파이썬은 변수 선언 X)  
    ex. int a = 10; (초깃값이 있는 경우)  
    ex. int a; (초깃값이 없는 경우) -> a에 쓰레기값 저장됨

        - static 변수
        처음 시작될 때 한번만 초기화하고, 프로그램 종료될 때까지 메모리 유지
        (만약, 함수 내에 static 변수가 있다면 그 함수가 여러번 호출되어도 초기화 반복하지 X)

-   배열  
    \- 같은 타입 변수들로 이루어진 집합 - 배열 선언  
     >\- 1차원 배열 (초깃값 없어도 됨)  
     (c언어) 타입 배열명 [요소_개수] = {초깃값};  
     (자바) 타입 [ ]배열명 / 타입 배열명[ ] = new 타입[요소_개수];

            >\- 2차원 배열 (초깃값 없어도 됨)
        (c언어) 타입 배열명[ 행 ][ 열 ] = {초깃값};
        (자바) 타입 배열명[ ][ ] / 배열명[ ][ ] = \{\{초깃값}, {초깃값}...};
        \* (자바) 2차원 배열에서 배열명이 a일때, a.length => 행개수, a[0].length => 열개수

-   포인터  
    \- 변수의 주솟값을 저장하는 공간(C언어에서 쓰임)  
     >\- 포인터 선언  
     데이터*타입\* 포인터*변수명 = &변수명

-   배열과 포인터

    -   1차원 배열과 1차원 포인터  
        \- 1차원 배열에서 배열명만 단독 사용할 경우 1차원 포인터와 동일  
        \- **1차원\_배열**일 때 배열명[요소], _(배열명+요소), **1차원\_포인터**일 때 포인터[요소], _(포인터+요소) 같은 값  
         >ex.  
        int a[4] = {1,2,3,4};  
        int* p = a;  
        a = 주소 = &a[0]  
        **배열의*주소는*배열명이고,** **배열의*첫번째*값은(index=0)*\*a*이다**
        (a+1)==&a[1]  
        a[0] == *a  
        a[1] == *(a+1)  
        p[0] == a[0] == *p

    -   2차원 배열과 1차원 포인터  
        \- 2차원 배열에서 배열명만 단독 사용할 경우 2차원 포인터와 동일  
        \- **2차원\_배열**일 때 배열명[요소], *(배열명+요소)는 1차원 포인터와 동일  
        위의 식에 [] 또는 *를 추가해야 값을 얻을 수 있음  
         >ex.  
        _p = a[1] = a[1][0]  
        _(p+1) = a[1][1]

    -   2차원 배열과 포인터 배열

    -   2차원 배열과 2차원 포인터  
        \- 2차원 배열에서 배열명만 단독으로 사용할 경우 2차원 포인터와 동일  
        \- **2차원\_배열**일 때, 배열명[요소][요소], _배열명[요소], \*\*(배열명+요소)일 경우 값을 가리킴  
        \* 포인터 변수 선언할 때 ()없으면 2차원 배열에 대한 포인터가 아닌 포인터 배열임  
         >ex. int (_ p)[2] = a;

    -   1차원 배열과 문자열  
        \- 문자열을 초기화할 때 마지막 NULL 문자가 삽입되므로 초기화하는 글자수보다 1이상 큰 값으로 배열을 선언(크기 명시가 없으면 자동으로 글자수 +1)  
        \- printf 함수에서 %s를 이용하여 읽고 출력하는데, 읽기 시작한 주소 알려주면 시작 주소부터 NULL전까지 읽음

    -   2차원 배열의 문자열  
        \- 문자열을 여러 개 정의할 때 2차원 배열을 사용

c. 자료형

-   자바

    -   HashSet  
        \- Set의 자식 클래스로 중복된 원소를 허용하지 않는 집합의 성질을 가지고 있는 자료형이며 클래스  
         >Set 변수명 = new HashSet();  
        HashSet 변수명 = new HashSet();

            - 메서드
            \- add(값): 값을 추가하는 메서드(중복된 값 들어오면 추가하지 X)
            \- remove(값): 값을 제거하는 메서드
            \- size(): 원소의 개수를 얻는 메서드

    -   ArrayList  
        \- List의 자식 클래스로 크기가 가변적으로 변하는 선형리스트의 성직을 가지고 있는 자료형이며 클래스(검색에 용이)  
        \* ArrayList를 LinkedList로 변경하면 LinkedList처럼 동작  
         >List 변수명 = new ArrayList();  
        ArrayList 변수명 = new ArrayList();

            - 메서드
            \- add(값): 값 추가
            \- add(인덱스, 값): 해당 인덱스에 값 추가
            \- remove(인덱스): 해당 인덱스에 있는 값 제거
            \- get(인덱스): 해당 인덱스에 값을 얻는 메서드
            \- size(): 들어있는 원소의 개수

    -   LinkedList: 데이터를 저장하는 노드가 이전 노드와 다음 노드의 상태를 알고 있는 링크드리스트 자료구조를 구현한 클래스
    -   HashMap  
        \- 키와 값으로 구성된 객체를 저장하는 구조로 되어 있는 자료구조를 구현한 자료형이며 클래스  
         >Map 변수명 = new HaspMap();  
        HashMap 변수명 = new HashMap();

            - 메서드
            \- put(키, 값): 해당 키에 해당하는 값을 추가
            \- remove(키): 해당 키에 해당하는 값을 제거
            \- get(키): 해당 키에 해당하는 값을 얻는 메서드
            \- size(): 들어있는 원소의 개수

-   파이썬

    -   세트형  
        \- 중복된 원소를 허용하지 않는 집합의 성질을 가지고 있는 자료형  
         >세트명 = set([요소1, 요소2, ...])  
        세트명 = {요소1, 요소2, ...}

            - 메서드
             add(값): 값 추가
             update([...]): 여러 개의 값을 한꺼번에 추가
             remove(값): 특정 값을 제거

    -   리스트형  
        \- 크기가 가변적으로 변하는 선형리스트의 성질을 가지고 있는 자료형  
         > 리스트명 = [요소1, 요소2,...]

            - 메서드
            append(값): 리스트 마지막 요소 뒤에 값을 추가
            insert(인덱스, 값): 인덱스 위치에 값을 삽입
            remove(값): 해당하는 값을 제거, 값이 여러개 있을 경우 맨 앞에 있는 값 제거

            \- 리스트 인덱싱
            첫번째 요소: 0 / -n
            두번째 요소: 1 / -(n-1)
            마지막 요소: n-1 / -1

            \- 리스트 슬라이싱
            >리스트명[시작 인덱스 : 종료 인덱스 : 스텝]
            \-시작 인덱스: 슬라이싱을 시작할 인덱스, 생략할 경우 처음부터 시작
            \-종료 인덱스: 슬라이싱을 종료할 인덱스, 종료 인덱스 -1까지만 슬라이싱, 생략할 경우 마지막까지 슬라이싱
            \-스텝: 몇 개씩 끊어서 슬라이싱을 할지 결정, 생략시 1이 기본값

    -   튜플형  
        \- 초기에 선언된 값에서 값을 생성, 삭제, 수정이 불가능한 형태의 자료형  
         >튜플명 = (요소1, 요소2, ...)

            \- 튜플 인덱싱, 슬라이싱은 리스트 인덱싱, 슬라이싱과 동일

    -   딕셔너리형  
        \- 키와 값으로 구성된 객체를 저장하는 구조로 되어 있는 자료형  
         >딕셔너리명 = {키1:값1, 키2:값2, ...}

            \-요소 추가 : 딕셔너리명[키] = 값
            \-요소 삭제 : del 딕셔너리명[키]

d. 식별자

-   개념  
    \- 변수, 상수, 함수 등 서로 구분하기 위해서 사용되는 이름

-   명명 규칙

    -   사용 가능 문자 : 영문 대문자/소문자, 숫자, 밑줄(\_)

    -   변수 사용 규칙  
        \- 첫 자리에 숫자 사용 X  
        \- 변수 이름의 중간에 공백 사용 X

    -   변수 의미 부여  
        \- 데이터값의 의미나 역할 표현  
        \- 예약어는 변수로 사용 X

-   식별자 표기법
    -   카멜 표기법(Camel Case): 여러 단어가 이어지면 **첫** **단어** **시작**만 **소문자**로 표시하고, 각 단어의 첫 글자는 **대문자**로 지정
    -   파스칼 표기법(Pascal Case): 여러 단어가 이어지면 **각** **단어의** **첫글자**는 **대문자**로 지정
    -   스네이크 표기법(Snake Case): 여러 단어가 이어지면 단어 사이에 **언더바**를 넣는 표기법
    -   헝가리안 표기법(Hungarian Case): 두어에 **자료형**을 붙이는 표기법, int형은 n / char형은 c / 문자열의 경우 sz

### 3. 연산자

-   산술 연산자 (+,-,\*,/,%)
-   시프트 연산자 (<<,>>)
-   관계 연산자 (<,>,=<,>=,==,!=)
-   논리 연산자 (&&,||)
-   비트 연산자 (&,|,^,~)
-   대입 연산자 (=,+=,-=,\*=,/=,%=)
-   증감 연산자 (++x,x++,--x,x--)
-   삼항 연산자 (조건 ? 참일 때 값 : 거짓일 때 값)

### 4. 표준 함수

a. 출력 함수

-   C언어
    -   단순출력 : printf(""); (stdio.h헤더 선언 필요)
    -   변수출력 : C언어만 해당 변수에 저장된 값 출력할 때에는 포맷스트링 이용
-   C++

    -   단순출력 : std::cout << 문자열; (iostream 헤더 선언 필요)
    -   using namespace std; 선언하면 std:: 생략 가능
    -   개행 : std::endl;
    -   변수출력 : std::cout << 변수명;

-   JAVA
    -   단순출력 : Systeml.out.println(문자열); ln없으면 개행 X
    -   변수출력
        \- System.out.println(변수명);  
        \- System.out.printf(포맷\_스트링, 변수명);
-   Python
    -   단순출력 : print(문자열), print(문자열, end='') => 개행X
    -   변수출력 : print(변수명)

b. 입력 함수

-   C언어
    -   변수값 입력 : scanf(포맷\_스트링, &변수명);
    -   문자열 입력 : scanf("%s", 배열명);
    -   scanf 사용시 stdio.h 선언 필요
    -   문자열 입력받는 경우가 아니라면 변수명 앞에 '&'을 붙임
    -   문자열 입력받는 경우 배열명을 쓰고 '&' 안붙임
-   C++

    -   변수값 입력 : std::cin >> 변수명
    -   iostream 헤더 선언 필요

-   JAVA
    -   Scanner 클래스를 스캐너 변수에 생성
    -   스캐너 변수를 이용해 정수형은 nextInt, 실수형은 nextFloat,nextDouble, 문자열은 nextLine을 통해 입력받음
        > ex.  
        >  public static void main(String[] args) {  
        > String s; int i; float f;  
        >  Scanner c = new Scanner(System.in);  
        >  s = c.nextLine();  
        >  System.out.println(s);  
        >  i = c.nextInt();  
        >  System.out.println(i);  
        >  f = c.nextFloat();  
        >  System.out.print(f);  
        >  }
-   Python
    -   숫자를 입력받을 때는 문자열로 저장 후 eval 함수를 써서 숫자로 변환
    -   변수명 = input()
    -   변수명 = eval(변수명)

### 5. 명령문

### 6. 사용자 정의 자료형 활용

\- 사용자가 상황에 맞게 기존 자료형들을 조합해서 만드는 자료형

-   열거체  
    \- 서로 연관된 **정수형** 상수들 집합  
    \- 정수형 상수에 이름을 붙여서 이해 쉬워짐

-   구조체  
    \- 사용자가 기본 타입을 가지고 새롭게 정의할 수 있는 사용자 정의 자료형  
    \- 자바와 파이썬에서는 지원하지 X(class를 이용하여 struct 기능을 구현할 수 O)  
     - 포인터  
     \- 일반 구조체 변수로 접근할 때는 .으로 접근  
     ex. s.gender  
     \- 구조체 포인터로 접근할 때는 ->로 접근  
     > ex.  
     *p = &s  
     s.gender (*p).gender
    p->gender (&s)->gender

### 7. 사용자 정의 함수

a. main함수

b. 사용자 정의 함수

c. 함수 포인터

d. 매개변수 전달방법

-   call by value  
    \- 변수의 값을 넘겨주고, 이 값은 새로운 공간에 할당되어 사용하는 방식  
    \- 형식 매개변수의 어떠한 변화도 실 매개변수에 아무런 영향을 미치지 않음

-   call by reference  
    \- 변수의 값이 아닌 변수가 사용 중인 메모리 공간의 주소를 넘겨주는 방식  
    \- 실 매개변수의 주소를 형식 매개변수로 보냄

### 8. 재귀 함수

### 9. 클래스

\- 객체지향 프로그래밍(OOP)에서 특정 객체를 생성하기 위해 변수와 메서드를 정의하는 틀 (C언어는 지원X)  
\- 변수와 메서드 형태로 구성  
\- 변수는 변수 선언과 동일, 메서드는 사용자 정의함수와 동일 문법  
\- 파이썬은 별도로 변수 선언 하지 않기 때문에 메서드 형태로 구성

a. 접근제어자

b. 클래스 사용

c. 생성자

d. 소멸자

e. 상속  
 \- 어떤 객체가 있을 때 그 객체의 변수와 메서드를 다른 객체가 물려받는 기능

-   오버로딩

-   오버라이딩

-   상위클래스 접근

f. 추상클래스  
\- 미구현 추상 메서드를 한개 이상 가지며 자식 클래스에서 해당 추상 메서드를 반드시 구현하도록 강제

g. 인터페이스

-
-
-
-
-

## 02. 언어 특성 활용하기

### 1. 프로그래밍 언어의 언어별 특성

a. 프로그래밍 언어의 유형 분류  
b. 프로그래밍 언어별 특성  
c. 객체지향 프로그래밍

### 2. 라이브러리 활용
