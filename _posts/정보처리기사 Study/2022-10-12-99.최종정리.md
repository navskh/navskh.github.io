# 최종정리 


#### 디자인 패턴  
  
디자인 패턴이란?  
공통으로 발생하는 문제에 대한 자주 쓰이는 설계 방법을 정리  
  
  
##### 디자인패턴의 유형

목적
- 생성 : 객체 인스턴스 생성할 때의 패턴
- 구조 : 더큰 구조 형성을 목적으로 함.
- 행위 : 클래스나 객체들의 상호작용하는 방법, 역할 분담 다룸.

범위
- 클래스 : 클래스간의 관련성, 컴파일 타임에 정적으로 결정
- 객체 : 객체 간 관련성, 런타임에 동적으로 결정

위의 내용도 외워야겠지만
결국에는 
생성의 종류
구조의 종류
행위의 종류 ..

이런식으로 각 종류가 뭐가 있는지..
뭐가 어떤건지 등을 알고 있어야 한다.


#### 디자인 패턴 종류

##### 생성패턴

- Builder  
    객체를 구현하는 방법과 생성하는 방법을 분리하였다.
    예를 들면 Director 객체가 있고
    ToyBuilder 객체가 있음
    PoohBuilder 객체를 만든 상태에서 곧바로 pooh를 만들 수 없고
    Director에게 가서 이거 만들어주세요 해야 함.
    toy를 만들 땐 director에게 가야하지만
    toy의 형태는 내가 설정해줘야 하는 것임.
    동일한 절차로 다양한 애들을 만들어줄 수 있다는 것이 핵심 
    [참고링크](https://4z7l.github.io/2021/01/19/design_pattern_builder.html)

- Prototype 패턴   
    프로토타입을 만들어서 복제를 용이하게 만든 것임
    예를들면 Car라는 객체를 만들었다.
    근데 Car2에는 어떤 데이터를 추가해야하고
    Car3에는 어떤 데이터를 빼주어야 한다면
    Car를 만들고 Car.clone 해서 복제해서 
    Car2, Car3를 조작할 수 있도록 만든 것이 Prototype 패턴이다.
    [참고링크](https://keencho.github.io/posts/prototype-pattern/)

- Factory Method 
    부모에는 전체적인 영역의 클래스를 정의하고
    객체를 만들어주는 클래스는 하위(자식)클래스에서 만들어줌.
    다양한 자식클래스에 맞게 다양한 형태의 객체를 생성
    이렇게 하면 결합도가 줄어들므로 하위 클래스 간에 독립성을 가져서
    수정이 용이함.

    예를들어 설명하자면, 피자스토어라는 클래스가 있고
    시카고 피자스토어, 뉴욕 피자스토어라는 서브클래스를 만들면
    뉴욕 피자를 만들고 싶으면 뉴욕피자 스토어로 만들고
    시카고 피자를 만들고 싶으면 시카고피자 스토어로 만들어 주게 해준다.
    [참고링크](https://dev-youngjun.tistory.com/195)

- Abstract Factory  
    추상 팩토리 패턴은 팩토리 패턴에서 생길 수 있는 단점을 보완하기 위해 나왔다

    **기존의 팩터리 패턴**
    ![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile21.uf.tistory.com%2Fimage%2F998FC33C5C25BD7C026317)

    **추상팩터리 패턴**
    ![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile9.uf.tistory.com%2Fimage%2F995759355E34E9DE086856)

    - 팩토리 메서드 패턴
      조건에 따른 객체 생성을 팩토리 클래스로 위임하여, 팩토르 클래스에서 객체를 생성하는 패턴
    - 추상 팩토리 패턴
      서로 관련이 있는 객체들을 통째로 묶어서 팩토리 클래스로 만들고, 이들 팩토리를 조건에 따라 생성하도록 다시 팩토리를 만들어서 객체를 생성하는 패턴

- Singleton  
    최초 한번만 인스턴스를 만들고 그 인스턴스를 가지고 공유해서 사용하겠다. (메모리 누수의 방지, 동시성 문제를 고려)
    ![img](https://blog.kakaocdn.net/dn/b14f56/btq15ZNqHQO/2kNjRZJmdoZ1Z9KvdvIDL0/img.png)

##### 구조패턴

- Bridge
    > "구현(implementation)으로부터 추상(abstraction) 레이어를 분리하여 이 둘이 서로 독립적으로 변화할 수 있도록 한다." 

    ![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdD0SuR%2FbtqwsXr3dGN%2FgcLPkY2KvJOiW1nqUGkQsk%2Fimg.png)

- Decorator
    > 어떤 객체에 책임(기능)을 동적으로 추가하는 패턴

    ![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbnP6V5%2Fbtq1JVdeaQb%2F0DLKqgOGPfhb2qhfZmKWRk%2Fimg.png)

    예를 들면, 앱을 만들다 보면, Container 라는 애가 있는데, 얘의 테두리를 감쌀 때, 여러가지 속성들을 줘야하는 경우
    Decoration 이라고 하는 애를 추가해서 거기 안에서 지지고 볶고 함으로써 커스터마이징을 할 수 있다.

- Facade
    > 서브시스템들의 공통적인 기능을 정의하는 단순화된 상위 수준의 인터페이스를 정의하는 패턴이다

    ![img](https://dev-aiden.com/assets/images/2021-08-26-Facade-Pattern/2.png)


- Flyweight
    >​ 인스턴스를 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴
    > '공유(Sharing)'를 통하여 대량의 객체들을 효과적으로 지원하는 방법

    - 싱글톤 패턴이랑 차이가 뭘까
    싱글톤 패턴은 클래스 자체가 오직 1개의 인스턴스만 허용
    플라이웨이트 패턴은 싱글톤이 아닌 클래스를 팩토리에서 제어
    인스턴스 생성의 제한을 어디서 제어하느냐에 차이.
    ![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbmXxUU%2FbtrpcO3CO2L%2Fr6kSalIbyKTkIKuZqO2fH1%2Fimg.png)



- Proxy
    > Proxy는 우리말로 대리자, 대변인 이라는 뜻입니다
    해당 객체를 대행(대리, proxy)하는 객체를 통해 대상객체에 접근하는 방식을 사용하면 해당 객체가 메모리에 존재하지 않아도 기본적인 정보를 참조하거나 설정할 수 있고 또한 실제 객체의 기능이 반드시 필요한 시점까지 객체의 생성을 미룰 수 있습니다.

    ![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcqvG81%2FbtqZP26XLqF%2FT98BIpsaRI4mSBNQMxykvK%2Fimg.png)
- Composite
    > 컴포지트 패턴(Composite pattern)이란 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 한다.

    ![img](https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/Composite_UML_class_diagram_%28fixed%29.svg/960px-Composite_UML_class_diagram_%28fixed%29.svg.png)

    파일 디렉토리
    파일 class
    디렉토리 class
    이 것들을 모두 다루는 것을 컴포지트라는데 뭔소린지..

- Adapter
    >한 클래스의 인터페이스를 클라이언트에서 사용하고자하는 다른 인터페이스로 변환한다.어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.

    ![img](https://t1.daumcdn.net/cfile/tistory/24231F4C575EACA210)


##### 행위패턴

- Mediator
    >모든 클래스간의 복잡한 로직(상호작용)을 캡슐화하여 하나의 클래스에 위임하여 처리하는 패턴
    >M:N의 관계에서 M:1의 관계로 복잡도를 떨어뜨려 유지 보수 및 재사용의 확장성에 유리한 패턴

    ![img](https://velog.velcdn.com/images%2Fcham%2Fpost%2Fb2fca9b2-5f13-483f-b749-d1768d9285e4%2Fimage.png)

- Interpreter
    구글 번역기 !
    ![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fk8czB%2FbtroVk8l7AP%2FJL1zrwKybCXCtllSsXldWk%2Fimg.png)
    
    뭐 아무튼 해석해준다는 것이 핵심


- Iterator
    > 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 수 있는 방법을 제공한다.
    컬렉션 객체 안에 들어있는 모든 항목에 접근하는 방식이 통일되어 있으면 어떤 종류의 집합체에 대해서도 사용할 수 있는 다형적인 코드를 만들수 있다.

- Template Method
    > 알고리즘의 구조를 메소드에 정의하고, 하위 클래스에서 알고리즘 구조의 변경없이 알고리즘을 재정의 하는 패턴이다.

    ![img](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FmwMAk%2FbtqZVma7kxf%2FfSrEjx6C3Mc3Scd4P2OyL1%2Fimg.png)
    
- Observer
    > 어떤 '이벤트' 가 일어나는 것을 감시하는 패턴
    - 안드로이드를 예로 들어 설명하자면 아래와 같은 것들이 이벤트가 발생한 순간이라고 할 수 있다.
    사용자가 키보드를 눌렀을 때
    사용자가 어떤 버튼을 터치했을 때
    호출한 API의 응답 데이터가 수신됐을 때

    리스너를 만드는 것이 대표적인 옵저버 패턴임

- State
    >상태 패턴에서는 상태를 별도의 타입으로 분리하고 상태별로 알맞은 하위 타입을 구현한다

    ```javascript
    public interface State {
      State winLottery();

      State earnMoney();

      State loseMoney();

      State loseWinLottery();

      void printCurrentEmotion();
    }
    ```


- Visitor
    >비지터 패턴은 방문자와 방문 공간을 분리하여,
    방문 공간이 방문자를 맞이할 때, 이후에 대한 행동을 방문자에게 위임하는 패턴이다.


- Command
    >. 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴이다.


- Strategy
    >같은 문제를 해결하는 여러 알고리즘이 클래스별로 캡슐화되어 있고 이들이 필요할 때 교체할 수 있도록 함으로써 동일한 문제를 다른 알고리즘으로 해결할 수 있게 하는 디자인 패턴


    ![img](https://velog.velcdn.com/images%2Fy_dragonrise%2Fpost%2F01b02920-5e7d-4a90-b5be-7cdfe0f6091d%2Fimage.png)

- Memento
    >메멘토 패턴은 객체의 상태 정보를 저장하고 사용자의 필요에 의하여 원하는 시점의 데이터를 복원 할 수 있는 패턴을 의미합니다.

- Chain of Responsibility
    - Chain이라는 영어 단어는 연쇄, Responsibility라는 영어 단어는 책임, 즉 Chain of Responsibility는 책임의 연쇄라는 의미가 된다. 실제로는 회전하는 구조라고 생각하는 것이 이해하기 쉬울 것이다.
    - Chain of Responsibility 패턴은, 여러개의 객체를 체인으로 연결하여 그 객체의 체인을 순차적으로 걸어 가면서 최종적인 객체를 결정하는 방식이다.
    - 어떤 사람에게 요구 사항이 온다고 하였을 때, 그 사람이 바로 그것을 처리할 수 있으면 처리한다. 처리할 수 없다면 그 요구를 ‘다음 사람’으로 전달한다. 이후 계속적으로 반복하는 것이 Chain of Responsibility 패턴이다.
    
![img](https://www.devkuma.com/docs/design-pattern/design-pattern-chain-of-responsibility-class-diagram.png)


#### UI 설계 원칙

- 직관성  
  Intuitiveness  
  누구나 쉽게 이해하고, 쉽게 사용할 수 있어야 한다  
  -> UI를 보자마자 어떻게 사용하는 것인지 파악이 가능해야 함(로그인 버튼, 햄버거 메뉴 등)
- 유효성  
  Efficiency  
  사용자의 목적을 정확하게 달성해야 한다  
  -> 아무리 이해하기 쉽게 설계된 UI라도, 사용자가 이용하고자 하는 목적과 동떨어지면 잘 만든 UI가 아니다  
  (송금 버튼 대신 대표 캐릭터가 대문짝만하게 들어가 있는 은행 앱)
- 학습성  
  Learnability  
  누구나 쉽게 배우고 익힐 수 있어야 한다  
  -> 하나의 목적을 달성하기 위해 지나치게 많은 절차가 필요하거나, 번거로워서는 안된다
- 유연성  
  Flexibility  
  사용자의 요구사항을 최대한 수용하며, 오류를 최소화해야 한다  
  -> 결과적으로 유효성과 함께 한다. 잘 만든 UI라도 제대로 동작하지 않으면 목적 달성이 불가능하다

#### UI 품질 요구사항

- 기능성
- 신뢰성
- 사용성
- 효율성
- 유지보수성
- 이식성


#### 외워야할 것 모음  

> *개체관계 다이어그램를 사용하며 사용자의 요구에 대한 트랜잭션을 모델링하는 단계는 ?   
> 
> *정규화를 진행하며 트랙잭션의 인터페이스를 설계하는 단계, 사람이 이해하기 쉽게 표현한 모델링하는 단계는 ?  
> 
> *반정규화를 진행하며 각 DBMS의 특성을 고려하여 데이터베이스 저장 구조(물리 데이터 모델)로 변환하는 모델링 하는 단계는 ?  
<details>
  <summary>정답</summary>
  <div markdown="1">
    개념적 설계/ 논리적 설계 / 물리적 설계
  </div>
</details>

> 릴레이션/튜플/속성/카디널리티/차수/스키마/인스턴스 ? 

<details>
  <summary>정답</summary>
  <div markdown="1">
    릴레이션 : 행과 열로 구성된 테이블
    튜플 : 릴레이션의 행에 해당하는 요소
    속성 : 릴레이션의 열에 해당하는 요소
    카디널리티 : 튜플의 수
    차수  : 애트리뷰트의 수
    스키마 : 데이터베이스의 구조, 제약 조건 등의 정보를 담고 있는 기본적인 구조
    인스턴스  : 정의된 스키마에 따라 생성된 테이블에 실제 저장된 데이터의 집합
  </div>
</details>

> σ,π,⋈,÷ (연산자의 영어/한글이름)  
<details>
  <summary>정답</summary>
  <div markdown="1">
    σ : select : 조건을 만족하는 튜플을  반환
    π : project : 주어진 속성들의 값으로만 구성된 튜플 반환
    ⋈ : 공통 속성을 이용해 R과 S의 튜플들을 연결해 만들어진 튜플을 반환
    ÷ : 어떤 릴레이션의 모든 튜플과 관련있는 튜플을 반환
  </div>
</details>

> 이상현상에 대하여  
> 정보 저장 시 불필요한 세부정보를 입력해야하는 경우  
> 정보 삭제 시 원치 않는 다른 정보가 같이 삭제되는 경우  
> 중복 데이터 중에서 특정 부분만 수정되어 중복된 값이 모순을 일으키는 경우  
<details>
  <summary>정답</summary>
  <div markdown="1">
    삽입/삭제/갱신 이상
  </div>
</details>

> 정규화
<details>
  <summary>정답</summary>
  <div markdown="1">
    1정규형(1NF): 원자값으로 구성
    2정규형(2NF): 부분 함수 종속 제거
    3정규형(3NF): 이행함수 종속 제거(A→B, B→C ⇒ A→C 분리)
    보이스-코드 정규형(BCNF): 결정자 후보 키가 아닌 함수 종속 제거
    4정규형(4NF): 다치(다중 값) 종속 제거
    5정규형(5NF): 조인 종속 제거
  </div>
</details>

> 파일시스템  
> ISAM:  
> VSAM:  

<details>
  <summary>정답</summary>
  <div markdown="1">
    ISAM : 
      - Indexed Sequential Access Method 
      - 자료 내용은 주 저장부, 자료 색인은 자료가 기록된 위치와 함께 색인부에 기록되는 시스템
    VSAM : 
      - Virtual Stroage Access Method 
      - 대형 운영체제에서 사용되는 파일 관리시스템
  </div>
</details>



### 5. 개체-관계(E-R) 모델
![표기법](https://t1.daumcdn.net/cfile/tistory/222B1440570D9AF337)

- 표기법
    \- 개체(사각형)
    
    \- 관계(마름모)
    
    \- 속성(타원)
    
    \- 다중 값 속성(이중타원)
    
    \- 관계-속성 연결(선)
    
    \- 기본키(타원 내부 밑줄 선)

정규화 단계
        
    \- 1정규형(1NF): 원자값으로 구성
    
    \- 2정규형(2NF): 부분 함수 종속 제거
    
    \- 3정규형(3NF): 이행함수 종속 제거(A→B, B→C ⇒ A→C 분리)
    
    \- 보이스-코드 정규형(BCNF): 결정자 후보 키가 아닌 함수 종속 제거
    
    \- 4정규형(4NF): 다치(다중 값) 종속 제거
    
    \- 5정규형(5NF): 조인 종속 제거

    
### 7. 반 정규화(비정규화, 역정규화)
    
    - 정규화된 엔터티, 속성, 관계에 대해 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법
    
    - 반 정규화를 위해서는 데이터의 일관성과 무결성을 우선으로 할지, 데이터베이스의 성능과 단순화를 우선순위에 둘 것인지 조정하는 과정이 중요
 
#### 21년 2회

![16번](https://navskh.github.io/assets/img/21%EB%85%84%202%ED%9A%8C%2016%EB%B2%88.png)


<details>
  <summary>정답</summary>
  <div markdown="1">
    제2정규형
  </div>
</details>




#### EAI (Enterprise Application Integration) 

기업에서 운영되는 서로 다른 플랫폼 간의 정보를 
전달, 연계 통합이 가능하도록 해주는 솔루션

각 비즈니스 간 통합, 연계를 증대시켜 효율성을 높여줄 수 있다.
각 시스템 간의 확장성을 높여줄 수 있다.

![EAI](../../../../assets/img/EAI.jpg)

EAI의 구성요소

![EAI 구성도](https://t1.daumcdn.net/cfile/tistory/14733C134B503A3207)

- EAI 플랫폼 : 이기종 시스템 간에 애플리케이션 상호 운영, 데이터의 신뢰성 있는 전송, 대규모 사용자 환경 지원
- 어댑터 : 데이터 입출력 도구 (기업에서 자체 개발)
- 브로커 : 데이터가 전송 될 때, 데이터 포맷과 코드를 변환하는 솔루션
- 메세지 큐 : 비동기 메시지를 사용하는 다른 응용프로그램 사이에 데이터 송수신할 때 사용
- 비즈니스 워크플로우 : 미리 정의된 기업의 비즈니스 Workflow에 따라 업무를 처리하는 기능

#### EAI의 구축 유형

- 포인트 투 포인트 (Point to Point) 
    - 가장 기초적인 애플리케이션 통합 방법
- 허브앤스포크 
    - 단일한 접점의 허브 시스템을 통하여 데이터 전송 (중앙집중식)
    - 허브 망가지면 전체 장애
- 메시지 버스
    - 애플리케이션 사이 미들웨어 (버스)를 두어 연계하는 미들웨어 통합방식
    - 뛰어난 확장성과 대용량 데이터 처리 가능 
- 하이브리드
    - 그룹 내에선 허브앤 스포크, 그룹 간에는 메세지 버스를 사용하는 통합방식

#### ESB(Enterprise Service Bus) 방식

EAI 와 비슷한 개념이지만 약간 다름
기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션들 간을 하나의 시스템으로 운영할 수 있도록 함.

ESB는 Bus를 중심으로 각각 프로토콜이 호환할 수 있도록 애플리케이션의 통합을 느슨한 결합 방식으로 지원함.

![ESB](https://it.ucla.edu/sites/default/files/media/images/esb_diagrams_1b.jpg)



#### 웹서비스 방식

우리 회사에서도 많이 사용하는 방식

예를들어 디비와 통신할 때, 각 프로시저를 호출할 때 웹서비스를 만들어 둔것에서 가져온다고 보면 됨.

유형
- SOAP 
- UDDI
- WSDL 


##### 1) SOAP (Simple Object Access Protocol)

http, https, smtp 등 다양한 종류의 프로토콜을 사용하여
xml 기반의 메시지를 네트워크 상태에서 교환하는 프로토콜이다.

##### 2) WSDL (Web Service Description Language)

웹 서비스 명, 제공 위치, 메시지 포맷, 프로토콜 정보 등이 XML 로 저장되어 있다.

##### 3) UDDI (Universial Description, Discovery and Integration)

wsdl 을 등록하고 검색하기 위한 저장소로 공개적인 접근 검색이 가능한 레지스트리



uddi : 도서관
wsdl : 찾아갈 수 있는애
soap : 프로그램 제공자 에게 받는 애

이렇게 외워야 함.


#### 4) REST

웹과 같은 분산 하이퍼미디어 환경에서 자원의 존재/상태 정보를 표준화된 HTTP 메서드로 주고받는 웹 아키텍처  
HTTP URI를 통해 자원을 명시하고 HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것

- Create : `POST`
- Read : `GET`
- Update : `PUT`
- Delete : `DELETE`

> REST 구성요소
>
> - 자원(Resource), URI  
>   서버에 존재하는 데이터의 총칭
> - 행위(Verb), Method  
>   클라이언트는 URI를 이용해 자원을 지정하고 자원을 조작하기 위해 Method를 사용한다
> - 표현(Representation)  
>   REST에서 하나의 자원은 JSON, XML, TEXT 등 여러 형태의 Representation으로 나타낼 수 있다

**REST의 특징**

- 유니폼 인터페이스(일관된 인터페이스)  
  특정 언어에 상관없이 사용 가능
- 무상태성(Stateless)  
  작업을 위한 상태 정보를 따로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만 단순 처리
- 캐시 처리 가능(Cacheable)  
  HTTP가 가진 캐싱 기능 적용 가능
- 자체 표현 구조(Self-descriptiveness)  
  API 메시지만 보고도 쉽게 이해할 수 있는 자체 표현 구조



#### 인터페이스 구현 검증 도구

- xUnit  
  **다양한 언어를 지원**하는 단위 테스트 프레임워크
- STAF  
  **서비스 호출 및 컴포넌트 재사용** 등 다양한 환경을 지원하는 테스트 프레임워크
- FitNesse  
  **웹 기반** 테스트케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크
- NTAF  
  FitNesse의 장점과 STAF의 장점 **결합**
- Selenium  
  다양한 브라우저 지원 및 개발언어를 지원하는 **웹 애플리케이션 테스트 프레임워크**
- watir  
  **Ruby 기반** 웹 어플리케이션 테스트 프레임워크


#### 중요 인터페이스 데이터의 암호화 전송 보안 기술

- IPSec(IP Security)  
  IP계층에서 보안 서비스 제공
- SSL/TLS  
  전송계층과 응용계층 사이에서 데이터 무결성 보장
- S-HTTP(Secure Hypertext Transfer Protocol)  
  클라이언트와 서버 간에 전송되는 모든 메시지를 각각 암호화하여 전송



#### 응집도

모듈의 독립성을 나타내는 정도(모듈 내부 구성요소 간 연관 정도)  
하나의 모듈은 하나의 기능을 수행할수록 응집도가 높다

> **응집도 유형**
>
> 1. 우연적 응집도 `Coincidental`  
>    모듈 내부의 각 구성요소가 연관 없음
> 2. 논리적 응집도 `Logical`  
>    유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리
> 3. 시간적 응집도 `Temporal`  
>    특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리
> 4. 절차적 응집도 `Procedual`  
>    모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행
> 5. 통신적 응집도 `Communication`  
>    동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여 있음
> 6. 순차적 응집도 `Sequencial`  
>    모듈 내에서 한 활동으로부터 나온 출력값을 다른 활동이 사용
> 7. 기능적 응집도 `Functional`  
>    모듈 내부의 모든 기능이 단일한 목적을 위해 수행됨

-> 응집도가 높아질수록 품질이 좋아진다(우연 < 기능)

#### 결합도

모듈 내부가 아닌 외부의 모듈과의 연관도 또는 모듈 간의 상호의존성  
소프트웨어 구조에서 모듈 간의 관련성을 측정하는 척도

> **결합도 유형**
>
> 1. 내용 결합도 `Content`  
>    다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우
> 2. 공통 결합도 `Common`
>    파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호 작용
> 3. 외부 결합도 `External`  
>    어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조
> 4. 제어 결합도 `Control`  
>    단순 처리할 대상인 값만 전달되는 게 아니라 어떻게 처리를 해야 한다는 제어 요소가 전달되는 경우
> 5. 스탬프 결합도 `Stamp`  
>    모듈 간의 인터페이스로 배열이나 오브젝트, 스트럭처 등이 전달되는 경우
> 6. 자료 결합도 `Data`  
>    모듈 간의 인터페이스로 값이 전달되는 경우

-> 결합도가 낮을수록 품질이 좋아진다(자료 < 내용)



#### 팬인/팬아웃

소프트웨어의 구성요소인 모듈을 계층적으로 분석하기 위해 활용  
팬인/팬아웃 분석을 통해 시스템의 복잡도 추정 가능

- 팬인  
  얼마나 많은 모듈들이 현재 모듈을 호출하는지  
  해당 모듈로 들어오는 상위 모듈 수
- 팬아웃  
  해당 모듈에서 호출하는 하위 모듈 수

![Untitled](https://mblogthumb-phinf.pstatic.net/20150310_68/xpiart_14259329871534lWzT_PNG/%C1%A6%B8%F1_%BE%F8%C0%BD.png2.png?type=w2)



- SQL 삽입(Injection)  
    - Form SQL Injection  
    - Union Sql Injection  
    - Stored PRocedure SQL Injection
    - Mass SQL Injection
    - Error-Based SQL Injection
    - Blind SQL Injection  
    >1. 응용 프로그램의 취약점 탐지  
    >2. 악의적인 SQL 구문 삽입하여 인증 우회  
    >3. 권한이 상승되어 DB의 정보 탈취 및 조작 실행  



## 기출문제 모음

### 2020년 1회


7) 다음에서 설명하는 해시 함수는?
> 128비트 암호화 해시 함수로 RFC 1321로 지정되어 있으며, 주로 프로그램이나 파일이 원본 그대로인지를 확인하는 무결성 검사 등에 사용된다. 1991년에 로널드 라이베스트(Ronald Rivest)가 예전에 쓰이던 MD4를 대체하기 위해 고안하였다

<details>
  <summary>정답</summary>
  <div markdown="1">
    MD5
  </div>
</details>

10) 다음에서 설명하는 서비스 거부 공격은?
> 패킷의 출발지 주소(Address)나 포트(port)를 임의로 변경하여 출발지와 목적지 주소(또는 포트)를 동일하게 함으로써, 공격 대상 컴퓨터의 실행 속도를 느리게 하거나 동작을 마비시켜 서비스 거부 상태에 빠지도록 하는 공격

<details>
  <summary>정답</summary>
  <div markdown="1">
    랜드 어택(Land Attack)
  </div>
</details>



### 2020년 2회

1) 다음 보기는 네트워크 인프라 서비스 관리 실무와 관련된 사례이다. 괄호안에 들어갈 가장 적합한 용어를 한글 또는 영문으로 쓰시오.
> 귀하는 IT회사의 보안관제실에서 근무하고 있다. 정보시스템 운영 중 자연재해나 시스템 장애 등의 이유로 대고객 서비스가 불가능한 경우가 종종 발생한다. 이를 대비하여 백업 및 복구 솔루션을 도입하고자 한다.
> 백업 및 복구 솔루션은 (            )와 복구 목표 시점(RPO) 기준을 충족할 수 있는 제품으로 선정해야 한다. (           )는 “비상사태 또는 업무중단 시점으로부터 업무가 복구되어 다시 정상가동 될 때까지의 시간” 을 의미하고 복구 목표 시점(RPO)는 "업무 중단 시 각 업무에 필요한 데이터를 여러 백업 수단을 이용하여 복구할 수 있는 기준점"을 의미한다.

<details>
  <summary>정답</summary>
  <div markdown="1">
    목표 복구 시간(RTO; Recovery Time Objective)
  </div>
</details>

8) 네트워크 계층(network layer, 3계층)인 인터넷 프로토콜(IP)에서 '암호화', '인증', '키 관리'를 통해 보안성을 제공해 주는 표준화된 기술

<details>
  <summary>정답</summary>
  <div markdown="1">
    IPSec
  </div>
</details>


14) 소프트웨어 보안 취약점 중 하나인 SQL Injection에 대해 간략히 설명하시오.

<details>
  <summary>정답</summary>
  <div markdown="1">
    웹 페이지의 입력값을 통해서 SQL명령어를 주입하여 오동작을 일으키는 해킹방법
  </div>
</details>

### 2020년 4회

7) 해킹 공격의 종류 중 하나인 스니핑(Sniffing)에 대하여 설명하시오.


<details>
  <summary>정답</summary>
  <div markdown="1">
    네트워크상에 흘러다니는 트래픽을 훔쳐보는 행위. 주로 자신에게 와야할 정보가 아닌 정보를 자신이 받도록 조작하는 행위
  </div>
</details>


20) 정보 보안의 3요소 중 가용성(Availability)에 대하여 설명하시오.

<details>
  <summary>정답</summary>
  <div markdown="1">
    인가된 사용자는 원할 때 정보에 접근이 가능해야 함
  </div>
</details>


### 2021년 1회

18) 시스템 객체의 접근을 개인 또는 그룹의 식별자에 기반을 둔 방법, 어떤 종류의 접근 권한을 가진 사용자가 다른 사용자에 자신의 판단에 따라 권한을 허용하는 접근제어 방식은 ?

<details>
  <summary>정답</summary>
  <div markdown="1">
    임의적 접근 통제(DAC, Discretionary Access Control)
  </div>
</details>


### 2021년 2회

8) 미국 국립 표준 기술연구소 (NIST), DES를 대체하며, 128 비트 블록 크기와 128,192,256비트 키 크기의 대칭 키 암호화 방식은?

<details>
  <summary>정답</summary>
  <div markdown="1">
    AES (Advanced Encryption Standard)
  </div>
</details>


### 2021년 3회
4) 다음은 스푸핑 공격에 대한 설명이다. 괄호안에 들어갈 알맞은 답안을 작성하시오.
> ( ) 스푸핑은 근거리 통신망 하에서 ( ) 메시지를 이용하여 상대방의 데이터 패킷을 중간에서 가로채는 중간자 공격 기법이다. 이 공격은 데이터 링크 상의 프로토콜인 (  )를 이용하기 때문에 근거리상의 통신에서만 사용할 수 있는 공격이다.

<details>
  <summary>정답</summary>
  <div markdown="1">
    ARP
  </div>
</details>


10) 다음에서 설명하는 블록 암호 알고리즘을 적으시오.
> 이것은 미국 NBS (National Bureau of Standards, 현재 NIST)에서 국가 표준으로 정한 암호 알고리즘으로, 64비트 평문을 64비트 암호문으로 암화하는 대칭키 암호 알고리즘이다. 키는 7비트마다 오류검출을 위한 정보가 1비트씩 들어가기 때문에 실질적으로는 56비트이다. 현재는 취약하여 사용되지 않는다.

<details>
  <summary>정답</summary>
  <div markdown="1">
    DES
  </div>
</details>


### 2022년 1회

11) 다음에서 설명하는 공격 기법을 쓰시오.
> 이 공격은 APT 공격에서 주로 쓰이는 공격으로, 공격 대상이 방문할 가능성이 있는 합법적인 웹 사이트를 미리 감염시킨 뒤, 잠복하고 있다가 공격 대상이 방문하면 대상의 컴퓨터에 악성코드를 설치하는 방식이다.

<details>
  <summary>정답</summary>
  <div markdown="1">
    워터링 홀(Watering Hole)
  </div>
</details>





#### 화이트 박스 테스트

- 구문 커버리지/문장커버리지 : 프로그램 내의 모든 명령문을 적어도 한번 수행하는 커버리지, 조건문 결과와 관계 없이 구문 실행 개수로 계산
- 결정 커버리지/선택커버리지/분기커버리지 : 각 분기의 결정 포인트 내의 전체 조건식이 적어도 한번은 참과 거짓의 결과를 수행하는 테스트 커버리지 
- 조건 커버리지 : 결정 포인트 내의 각 개별 조건식이 적어도 한 번은 참과 거짓의 결과가 되도록 수행하는 테스트 커버리지 
- 조건/결정 커버리지 : 전체 조건식 뿐만 아니라 개별 조건식도 참 한번, 거짓 한번 결과가 되도록 수행
- 변경 조건/결정 커버리지 : 개별 조건식이 다른 개별 조건식에 영향을 받지 않고 전체 조건식에 독립적으로 영향을 주도록 함으로써 조건 결정 커버리지를 향상시킨 커버리지
- 다중 조건 커버리지 : 결정 조건 내 모든 개별 조건식의 모든 가능한 조합을 100% 보장하는 커버리지
- 기본경로 커버리지/경로커버리지 : 수행 가능한 모든 경로를 테스트 하는 기법
- 제어흐름 테스트 : 프로그램 제어 구조를 그래프 형태로 나타내어 내부 로직을 테스트하는 기법
- 데이터 흐름 테스트 : 제어 흐름 그래프에 데이터 사용현황을 추가한 그래프를 통해 테스트하는 기법

#### 블랙박스 테스트 

- 동등 분할 테스트/동치 분할 테스트/ 균등 분할 테스트/ 동치 클래스 분해 테스트 : 입력 데이터의 영역을 유사한 도메인 별로 유효값/ 무효값을 그룹핑하여 대푯값 테스트 케이스를 도출하여 테스트하는 기법
- 경곗값 분석 테스트/한계값 테스트 : 경계값을 포함하여 테스트 케이스를 설계하여 테스트하는 기법, 최소값, 최대값 등등...
- 결정 테이블 테스트 : 요구사항의 논리와 발생조건을 테이블 형태로 나열하여 조건과 행위를 모두 조합하여 테스트하는 기법
- 상태 전이 테스트 : 테스트 대상, 시스템이나 객체의 상태를 구분하고, 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행하는 테스트 기법
- 유스케이스 테스트 : 시스템이 실제 사용되는 유스케이스로 모델링 되어있을 때 프로세스 흐름을 기반으로 테스트 케이스를 실행하는 기법
- 분류 트리 테스트 : 테스트 데이터 값들 간에 최소한 한번씩은 조합하여 테스트
- 원인-결과 그래프 테스트 : 그래프를 활용하여 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스 선정
- 비교 테스트 : 여러 버전의 프로그램에 같은 입력값을 넣어서 동일한 결과 데이터가 나오는지 비교해보는 테스트 



### (3) 정적 테스트 

1) 리뷰 (REVIEW)
> 결함을 검출하거나 프로젝트의 진행상황을 점검하기 위한 활동

2) 리뷰의 유형
- 동료 검토 : 2~3명이 진행하는 리뷰의 형태
- 인스펙션 : 전문가 팀이 검사
- 워크 스루 : 사전 검토한 후 짧은 시간의 회의로 문제 식별, 대안 조사, 개선 활동 학습 기회를 제공하는 비형식적 검토 기법

> 워크 스루는 작성자 본인이 회의를 주재하며 기록자 역할도 담당할 수 있다.


### (6) 테스트 오라클 

> 테스트 오라클은 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참 값을 입력하여 비교하는 기법이다.

#### 테스트 오라클 종류 

- 참 오라클
- 샘플링 오라클
- 휴리스틱 오라클
- 일관성 검사



#### 메모리 관리 기법

1. 반입 기법  
   보조기억장치에 보관 중인 프로그램이나 데이터를 주기억장치에 적재할 시기를 결정하는 기법
   - 요구 반입 기법 : 실행 중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재
   - 예상 반입 기법 : 실행 중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재
2. 배치 기법  
   새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정
   - 최초 적합 : 빈 영역 중 첫 번째 분할 영역
   - 최적 적합 : 단편화를 가장 작게 남기는 분할 영역(사이즈가 가장 알맞은 영역)
   - 최악 적합 : 단편화를 가장 많이 남기는 분할 영역(사이즈가 가장 큰 영역)
3. 할당 기법
   주기억장치에 어떤 방법으로 할당할 것인지 결정
   - 연속 할당 기법
   - 분산 할당 기법
4. 교체 기법  
   재배치 기법, 주기억장치에 있는 프로세스 중 어떤 프로세스를 제거할 것인지
   - FIFO
   - LRU(Least Recently Used)
   - LFU(Least Frequently Used)




**프로세스 스케줄링 유형**

1. 선점형 스케줄링  
   다른 프로세스가 실행 중이더라도 운영체제가 CPU를 강제로 뺏을 수 있음  
   잦은 문맥 교환으로 오버헤드 많이 발생  
   Round Robin, SRT, 다단계 큐, 다단계 피드백 큐
2. 비선점형 스케줄링  
   프로세스가 CPU를 점유하고 있다면 이를 빼앗을 수 없는 방식  
   순서대로 처리되는 공정성 보장  
   FCFS, SJF, HRN, 우선순위, 기한부 등

> 선점형 스케줄링 기법
>
> 1. Round Robin  
>    순서대로 시간 단위로 CPU 할당(선입선처리)
> 2. SRT(Shortest Remaining Time First)  
>    가장 짧은 시간이 소요되는 프로세스 먼저 수행
> 3. 다단계 큐  
>    그룹으로 분류 가능하면 그룹에 따라 각기 다른 준비 상태 큐 이용  
>    하위 준비 상태 큐에 있는 프로세스를 실행하는 도중이라도 상위 준비 상태 큐에 프로세스가 들어오면 상위에 CPU 할당
> 4. 다단계 피드백 큐  
>    FCFS와 라운드 로빈 스케줄링 기법 혼합

> 비선점형 스케줄링 기법
>
> 1. FCFS(First Come First Serve)
> 2. SJF(Shortest Job First)  
>    실행 시간이 가장 짧은 프로세스에게 CPU를 할당
> 3. HRN(Highest Response Ratio Next)  
>    우선순위를 계산해서 프로세스들에게 순서를 부여  
>    




#### 클라우드 컴퓨팅

인터넷을 통해 가상화된 컴퓨터 시스템 리소스를 제공하고, 정보를 자신의 컴퓨터가 아닌 클라우드에 연결된 다른 컴퓨터로 처리하는 기술

- 사설 클라우드 : 가내 보유 컴퓨팅 자원 사용
- 공용 클라우드 : 클라우드 서비스 제공 업체 서비스 사용
- 하이브리드 클라우드 : 사설 + 공용 클라우드

> 클라우드 컴퓨팅 유형
>
> - 인프라형 서비스(IaaS) : 서버, 스토리지 같은 시스템 자원을 클라우드로 제공
> - 플랫폼형 서비스(PaaS) : 애플리케이션을 개발, 실행, 관리할 수 있게 하는 플랫폼을 제공
> - 소프트웨어형 서비스(SaaS) : 소프트웨어를 서비스 형태로 이용



#### 계층별 특징

1. 물리계층  
   0과 1의 비트 정보를 회선에 보내기 위한 전기적 신호 변환
2. 데이터 링크 계층  
   인접 시스템 간 데이터 전송, 전송 오류 제어  
   포인트 투 포인트 간 신뢰성 있는 전송을 보장하기 위한 계층
3. 네트워크 계층  
   단말기 간 데이터 전송을 위한 최적화된 경로 제공  
   데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능(라우팅)
4. 전송 계층  
   송수신 프로세스 간의 연결  
   양 종단간의 사용자들이 신뢰성 있는 데이터를 주고받을 수 있도록 해줌
5. 세션 계층  
   송수신 간의 논리적인 연결  
   양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법 제공
6. 표현 계층  
   데이터 형식 설정, 부호교환, 암복호화  
   응용 프로세스의 독립성을 제공하고 암호화
7. 응용 계층  
   사용자와 네트워크 간 응용서비스 연결, 데이터 생성  
   데이터의 최종 목적지
